//
// Created by oldlonecoder on 25-06-04.
//

#include "lexer.h"

////////////////////////////////////////////////////////////////////////////////////////////
//   Copyright (C) ...,2025,... by Serge Lussier
//   serge.lussier@oldbitsnbytes.club / lussier.serge@gmail.com
//   ----------------------------------------------------------------------------------
//   Unless otherwise specified, all Codes and files in this project is written
//   by the author and owned by the author (Serge Lussier), unless otherwise specified.
//   ----------------------------------------------------------------------------------
//   Copyrights from authors other than Serge Lussier also apply here.
//   Open source FREE licences also apply to the code from the author (Serge Lussier)
//   ----------------------------------------------------------------------------------
//   Usual GNU FREE GPL-1,2, MIT... or whatever -  apply to this project.
//   ----------------------------------------------------------------------------------
//   NOTE : All source code that I am the only author, I reserve for myself, the rights to
//   make it to restricted private license.
////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------------------------------------------------------------


namespace tux::lang
{
lexer::lexer(token_reference_table* table, std::string_view a_text)
{
    source.tokens_table = table;
    source.text = a_text;
    scanner = a_text;
}


/**
 * Processes the next token in the input text and updates the provided token
 * data structure with the parsed information.
 *
 * This operator analyzes the source text using the lexer, skips any leading
 * whitespace, and attempts to parse a valid token. It expects the necessary
 * token reference table and input text to already be set. If successful, the
 * parsed token information is written into the provided token object. If an
 * error occurs or the input is invalid, the method handles exceptions and
 * returns an appropriate status code.
 *
 * @param token A reference to a `token_info` object that will be updated with
 * the details of the parsed token if the operation succeeds.
 *
 * @return A `rem::code` value representing the result of the operation:
 * - `rem::code::accepted` if the token was successfully parsed.
 * - `rem::code::eof` if the end of the input text has been reached.
 * - `rem::code::failed` if an error occurred during token parsing.
 */
rem::code lexer::operator>>(token_info& token)
{
    if (!source.tokens_table)
        throw sys::exception()[ sys::error(1) << "Tokens reference table must be set prior to call this method. - Aborting the lexer."];
    if (!scanner.has_text())
        throw sys::exception()[ sys::error(1) << "No text to scan  - Aborting the lexer."];

    if (scanner.eof()) return rem::code::eof;

    try
    {
        if (!parse_token(token))
        {
            auto l = sys::error(1);
            throw sys::exception()[l << " Failed to parse token: " << l << scanner.mark() << l];
        }
    }
    catch (sys::exception& e)
    {
        auto l = sys::except(1); l << e.what() << l;
        return rem::code::failed;
    }
    return rem::code::accepted;
}


/**
 * Assigns the configuration data to the lexer instance.
 *
 * This operator assigns the provided configuration data to the lexer. During
 * the assignment, all properties of the lexer are updated with the corresponding
 * values from the input configuration, including setting the source data and
 * initializing the scanner with the text content.
 *
 * @param data A reference to `lexer::config_data` containing the configuration
 * information to be assigned to the lexer. It includes source data and associated text.
 *
 * @return A reference to the updated lexer instance after the assignment
 * operation has completed.
 */
lexer& lexer::operator=(lexer::config_data&data)
{
    source = data;
    scanner  = data.text;
    return *this;
}


/**
 * Analyzes the next portion of the input text and attempts to generate a token.
 *
 * This method scans the input text using the provided tokens table and attempts
 * to construct a token by invoking `scan`. If the scan fails, further attempts are
 * made to parse the input as an identifier or a numeric value. If no valid token
 * can be generated, an exception is thrown. The processed token is pushed into the
 * internals of the lexer for further use.
 *
 * @param token A reference to `token_info` where the generated token will be stored.
 * The token is either directly scanned or generated by parsing if applicable.
 *
 * @return A result code of type `rem::code` to indicate the success or failure of
 * the operation. Possible outcomes could be related to completion, errors, or
 * unhandled cases in the input.
 */
rem::code lexer::parse_token(token_info&token)
{
    scanner.skip_ws();
    if(!parse_numeric(token))
        token = source.tokens_table->scan(scanner);

    if (!token)
    {
        if (!parse_identifier(token))
        {
            auto l = sys::aborted(1);
            throw sys::exception()[l << " Unhandled text: " << l << scanner.cursor << l];
        }
    }


    if (token.is_quote())
    {
        if (!parse_quotes(token))
        {
            auto l = sys::aborted(1);
            throw sys::exception()[l << " Unterminated literal string: " << l << scanner.mark() << l];

        }
    }
    if (token.is_comment())
    {
        if (!parse_comment(token))
        {
            auto l = sys::aborted(1);
            throw sys::exception()[l << " Unterminated multi-line comment: " << l << scanner.mark() << l];
        }
        return rem::code::accepted;
    }
    return push(token);
}


/**
 * Attempts to parse the input as an identifier token.
 *
 * This method scans for a valid identifier. If successful,
 * it populates the provided `token_info` structure
 * with details about the identifier, including its name, location, length,
 * and type. The token is marked as a mnemonic symbol and classified as an
 * identifier. If no valid identifier is found, the operation is rejected.
 *
 * @param token A reference to a `token_info` object where details of the parsed
 * identifier will be stored, such as its name, cursor position, and properties.
 *
 * @return A result code of type `rem::code` indicating the success or failure
 * of the parsing operation. The method returns `rem::code::accepted` if the
 * identifier is successfully parsed and `rem::code::rejected` otherwise.
 */
rem::code lexer::parse_identifier(token_info&token)
{

    if (auto [r,v] = scanner.scan_identifier();!!r)
    {
        token.name = "Symbol";
        token.cursor = scanner.location;
        token.cursor.begin = v.begin();
        token.cursor.end = v.end();
        token.cursor.length = v.length();
        token.properties.V = 1;
        token.t = lang::type::Id;
        token.s = lang::type::Id | lang::type::Leaf;
        token.m = lang::mnemonic::Identifier;
        return parse_f4ac(token);
        //return rem::code::accepted;
    }
    return rem::code::rejected;


}


/**
 * Parses a numeric token from the scanned input.
 *
 * This method attempts to interpret the input as a numeric constant using the scanner's
 * `scan_numeric` function. If successful, it converts the scanned numeric type to an
 * appropriate internal representation and populates the provided `token_info` with related
 * information such as type, size, and location details. If the input cannot be interpreted
 * as a valid numeric token, the function returns a rejection code.
 *
 * @param token A reference to `token_info` used for storing the details of the parsed
 * numeric token, such as its name, type, properties, and location.
 *
 * @return A `rem::code` indicating the outcome of the parsing process. If the numeric
 * token parsing succeeds, it returns `rem::code::accepted`; otherwise, it returns
 * `rem::code::rejected`.
 */
rem::code lexer::parse_numeric(token_info& token)
{

    auto [r,v] = scanner.scan_numeric();
    if (!r)
        return rem::code::rejected;

    std::map<strscan::numeric_data::size_type_enum, lang::type::value> conv =
    {
        {strscan::numeric_data::size_type_enum::i8, lang::type::I8},
        {strscan::numeric_data::size_type_enum::u8, lang::type::U8},
        {strscan::numeric_data::size_type_enum::i16, lang::type::I16},
        {strscan::numeric_data::size_type_enum::u16, lang::type::U16},
        {strscan::numeric_data::size_type_enum::i32, lang::type::I32},
        {strscan::numeric_data::size_type_enum::u32, lang::type::U32},
        {strscan::numeric_data::size_type_enum::i64, lang::type::I64},
        {strscan::numeric_data::size_type_enum::u64, lang::type::U64},
        {strscan::numeric_data::size_type_enum::f32, lang::type::F32},
        {strscan::numeric_data::size_type_enum::f64, lang::type::F64}
    };

    token.name = "Number";
    token.cursor = scanner.location;
    token.cursor.begin = v.seq.begin();
    token.cursor.end = v.seq.end();
    token.cursor.length = v.seq.length();
    token.properties.V = 1;
    token.t = lang::type::Number;
    token.s = lang::type::Number | lang::type::Leaf | lang::type::Const | lang::type::Literal | conv[v.size_type];
    token.m = lang::mnemonic::Numeric;
    //return parse_f4ac(token);
    return rem::code::accepted;
}


/**
 * Parses a section of input to extract a quoted literal.
 *
 * This method utilizes the scanner to attempt the extraction of a literal token
 * from the input. If the extraction fails, an error is logged, and the operation ends
 * with a rejected error code. On success, the token's attributes such as cursor position,
 * type, semantic classification, and mnemonic are populated accordingly to represent
 * a literal string.
 *
 * @param token A reference to `token_info` where the scanned and processed token
 * information for the quoted literal is stored. It includes details like the token's
 * position, type, and associated semantic and mnemonic classifications.
 *
 * @return A result code of type `rem::code` indicating whether the operation was
 * successful (`rem::code::accepted`) or failed (`rem::code::rejected`).
 */
rem::code lexer::parse_quotes(token_info& token)
{
    auto [r,v] = scanner.scan_literal();
    if (!r)
    {
        auto l = sys::error(1); l << "Failed to scan literal: " << l << scanner.mark() << l;
        return rem::code::rejected;
    }

    token.cursor  = scanner.location;
    token.cursor.begin = v.begin();
    token.cursor.end = v.end();
    token.cursor.length = v.length();
    token.properties.V = 1;
    token.t = lang::type::Literal;
    token.s = lang::type::Literal | lang::type::Leaf | lang::type::Const|lang::type::Text;
    token.m = lang::mnemonic::String;

    return rem::code::accepted;
}


/**
 * Analyzes the current token to determine if it represents an operator and
 * categorizes it as a prefix, postfix, or dereference operator based on the
 * context of surrounding tokens.
 *
 * This method evaluates the given token's mnemonic and modifies its properties
 * (type and state) according to its usage in the source text. It handles sign
 * prefix operators, prefix/postfix increment and decrement operators, and
 * dereference operators. The context is determined by inspecting the state of
 * previously parsed tokens.
 *
 * @param token A reference to `token_info` containing the token to be analyzed.
 * The token's properties such as type and flags might be updated according
 * to the operator's role.
 *
 * @return A result code of type `rem::code`. This indicates the parsing result
 * for the operator. Possible return values include:
 * - `rem::code::accepted` if the token has been successfully categorized as a
 *   valid operator.
 * - `rem::code::ok` if no additional categorization is required or if the
 *   operator does not match any specific criteria.
 */
rem::code lexer::parse_operator(token_info& token)
{
    if ((token.m == lang::mnemonic::Sub)|| (token.m == lang::mnemonic::Add))
    {
        if (source.tokens->empty() || (source.tokens->back().is_operator()))
        {
            // We have a sign prefix operator here...
            token.t = lang::type::Prefix;
            token.s &= ~lang::type::Binary;
            token.s |= lang::type::Prefix | lang::type::Sign | lang::type::Unary;

            return rem::code::accepted;
        }

        return rem::code::ok;
    }

    if ((token.m == lang::mnemonic::Decr)|| (token.m == lang::mnemonic::Incr))
    {
        // Check prefix decr|incr :
        if (source.tokens->empty() || (source.tokens->back().is_operator()))
        {
            // Decrement or Increment operator is prefix here.
            token.t = lang::type::Prefix;
            token.s &= ~lang::type::Postfix;
            token.s |= lang::type::Prefix| lang::type::Unary;
            return rem::code::accepted;
        }
        if (!source.tokens->empty() && (source.tokens->back().properties.V == 1))
        {
            // Decrement or Increment operator is postfix here.
            token.t = lang::type::Postfix;
            token.s &= ~lang::type::Prefix;
            token.s |= lang::type::Postfix | lang::type::Unary;
            return rem::code::accepted;
        }
    }

    if (token.m == lang::mnemonic::Mul)
    {
        if (source.tokens->empty() || (source.tokens->back().is_operator()))
        {
            // We have a dereference prefix operator here...
            token.t = lang::type::Prefix;
            token.s &= ~lang::type::Binary;
            token.s |= lang::type::Prefix | lang::type::Unary;
            token.m = lang::mnemonic::Deref;
            return rem::code::accepted;
        }
    }
    return rem::code::ok;
}


/**
 * Processes a comment token by determining its type and delegating
 * to the appropriate parsing method.
 *
 * This method evaluates the type of comment specified by the token's
 * mnemonic and directs it to either line comment parsing or block comment
 * parsing. If the token type does not match any known comment mnemonic,
 * the parsing operation is rejected.
 *
 * @param token A reference to `token_info` containing the token to be parsed.
 * The token's mnemonic is analyzed to determine the type of comment.
 *
 * @return A result code of type `rem::code` that indicates the outcome of the
 * operation. The possible values can indicate successful parsing of a comment,
 * or rejection if the token is not a valid comment type.
 */
rem::code lexer::parse_comment(token_info& token)
{

    switch (token.m)
    {
        case lang::mnemonic::LineComment:
            return parse_line_comment(token);
        case lang::mnemonic::BeginComment:
            return parse_block_comment(token);
        default: break;
    }
    return rem::code::rejected;
}


/**
 * Parses a line comment from the input, updating the scanner position accordingly.
 *
 * This method processes the input to identify the end of a line comment, defined
 * as the text extending up to a newline character or the end of the input. It
 * advances the cursor of the scanner to the position following the detected comment
 * and synchronizes the state of the scanner.
 *
 * @param token A reference to `token_info` which contains information about the
 * current token context. This includes the initial position of the line comment
 * being parsed.
 *
 * @return A result code of type `rem::code`, which will be `rem::code::accepted`
 * to indicate successful parsing of the line comment.
 */
rem::code lexer::parse_line_comment(token_info&token)
{
    //auto l = sys::debug(1); l << scanner.cursor << l;
    auto cc = scanner.cursor;
    cc += token.cursor.length;
    while ((*cc != '\r') && (*cc != '\n') && (cc < scanner.end)) ++cc;
    //l = sys::debug(1); l << scanner.mark() << l;
    scanner.cursor = cc;
    scanner.sync();
    return rem::code::accepted;
}


/**
 * Processes the input to identify and handle a block comment.
 *
 * This method begins scanning from the current cursor position and attempts
 * to parse a block comment in the input. It checks for proper termination
 * of the block comment and updates the scanner's cursor accordingly.
 * If the end of the input is reached without finding a valid closing sequence,
 * an error is logged, and the parsing is rejected.
 *
 * @param token A reference to `token_info` that provides information about the current token,
 * including its cursor position and other metadata.
 *
 * @return A result code of type `rem::code` indicating the outcome of the operation.
 * It returns `rem::code::accepted` if the block comment is successfully parsed,
 * and `rem::code::rejected` if the comment is unterminated or the parsing fails.
 */
rem::code lexer::parse_block_comment(token_info&token)
{
    auto cc = scanner.cursor;
    cc += token.cursor.length;
    while ((*cc != '*') && (cc < scanner.end)) ++cc;
    if(cc >= scanner.end)
    {
        auto l = sys::error(1); l << color::red << "unterminated bloc comment" << l;
        return rem::code::rejected;
    }
    ++cc;
    if (*cc == '/')
    {
        ++cc;
        scanner.cursor = cc;
        scanner.sync();
        return rem::code::accepted;
    }
    return rem::code::rejected;
}


/**
 * Parses and identifies specific patterns resembling implicit multiplication operations
 * between numeric literals and variables, enabling virtual multiplication handling.
 *
 * This function processes a mathematical context potentially representing implicit
 * multiplication (e.g., handling patterns like `2π` or `4a2c`). If the current context
 * does not support F4AC (implicit multiplication), or if tokens are not in a suitable
 * state such as preceding tokens not being numeric literals or whitespace being detected,
 * the function abstains from applying further parsing logic.
 *
 * The routine adjusts token data accordingly to represent a virtual multiplication operator,
 * constructs intermediary tokens, and appends these tokens to the current source tokens.
 * The operation also generates debugging information for observed patterns and token updates.
 *
 * @param token A reference to the `token_info` representing the current parsing state.
 * Modifications to the token involve pointer adjustments and updating token properties
 * to represent virtual multiplication.
 *
 * @return A result code of type `rem::code`. It represents whether the operation was successfully
 * applied (`rem::code::applied`) or if it was deemed non-applicable (`rem::code::notapplicable`).
 */
rem::code lexer::parse_f4ac(token_info& token)
{
    if (source.tokens->empty())
        return rem::code::notapplicable;
    if (std::isspace(*(token.cursor.begin-1)))
    {
        F4AC = false;
        return rem::code::notapplicable;
    }

    if (!F4AC && (!source.tokens->back().is_numeric_literal()))
            return rem::code::notapplicable;




    F4AC = true;
    //  Scan each identifier's character :
    // 4a2c(a + c)
    // ^
    // -----------
    // 2pi
    // 2π^3
    //
    auto mtoken = token;
    //...
    token.cursor.length = 1;
    token.cursor.end = token.cursor.begin;
    mtoken = source.tokens_table->get_by_mnemonic(lang::mnemonic::Mul);
    mtoken.cursor = token.cursor;
    mtoken.properties.V = 1; ///< Virtual Multiply...
    source.tokens->push_back(mtoken);
    auto l = sys::debug(1); l << "F4AC: " << l << token.to_string() << l;
    return rem::code::applied;

}


/**
 * Parses the source text and generates tokens using the lexer.
 *
 * This method processes the text provided to the lexer, generates tokens
 * by invoking the `parse_token` function, and stores them in the lexer’s
 * internal token list. If the required token table is not set or if there
 * is no input text to scan, an exception is thrown before commencing parsing.
 *
 * @return A pair containing a result code and the total number of tokens generated.
 * The result code is of type `rem::code` indicating the outcome of the parsing
 * (e.g., success or failure), while the second value is the total count of tokens
 * processed during the operation.
 */
std::pair<rem::code, size_t> lexer::parse()
{
    scanner = source.text;
    auto l  = sys::debug(1); l << "Parsing text: " << l << source.text << l;
    if (!source.tokens_table)
        throw sys::exception()[ sys::error(1) << "Tokens reference table must be set prior to call this method. - Aborting the lexer."];
    if (!scanner.has_text())
        throw sys::exception()[ sys::error(1) << "No text to scan  - Aborting the lexer."];

    try
    {
        token_info token{};
        do ; while (!!parse_token(token)); // Yep, let's see...
    }
    catch (sys::exception& e)
    {
        l = sys::except(1); l << e.what() << l;
        return {rem::code::failed, source.tokens->size()};
    }
    return {rem::code::success,source.tokens->size()};
}


/**
 * Provides diagnostic output of the lexer’s internal state for debugging purposes.
 *
 * This method generates a detailed log of all tokens processed by the lexer.
 * It retrieves the size of the current token list and iterates through each token,
 * appending its string representation to the log stream. The information is useful
 * for tracing the internal state of the lexer and verifying the correctness of
 * tokenization during development or troubleshooting.
 *
 * The log output is directed to the `sys::info` stream.
 */
void lexer::debug_dump() const
{
    auto l = sys::info(1); l << "scanned " << color::lime << source.tokens->size() << color::r << " tokens" << l;
    for (auto token : *source.tokens)
        l << token.to_string() << l;
}


/**
 * Pushes a token into the source token list and updates the scanner state.
 *
 * This method appends the provided token to the internal token list of the lexer.
 * After adding the token, the scanner advances its position based on the token's
 * length and skips any whitespace in the input text. The method determines whether
 * the end of the scanner's input has been reached and returns an appropriate result code.
 *
 * @param token A reference to `token_info` containing the token to be pushed into the token list.
 * The token includes information such as cursor positions and its length.
 *
 * @return A result code of type `rem::code`, where `rem::code::accepted` indicates that
 * there is more data to process, and `rem::code::eof` indicates that the end of the input
 * has been reached.
 */
rem::code lexer::push(token_info&token)
{
    source.tokens->push_back(token);
    scanner.step(token.cursor.length);
    //++scanner; // Je l'sais pas trop...
    scanner.skip_ws();
    // auto l = sys::info(1); l << a_token.to_string() << l;
    return !scanner.eof() ? rem::code::accepted : rem::code::eof;
};


} // namespace tux::lang
